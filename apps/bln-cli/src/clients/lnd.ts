import { base16, base64 } from "@scure/base";

import * as base from "./interface.ts";

interface LndConfig {
  baseUrl: string;
  credentials?: string;
  tlsCertificate?: string;
}

class ClientInner {
  private readonly baseUrl: string;
  // Credentials is the macaroon
  private readonly credentials: string | null;
  // FIXME :: do something with this
  private readonly tlsCertificate: string | null;

  constructor(config: LndConfig) {
    this.baseUrl = config.baseUrl;
    this.credentials = config.credentials ? config.credentials : null;
    this.tlsCertificate = config.tlsCertificate ? config.tlsCertificate : null;
  }

  public async request<T>(
    endpoint: string,
    method: "GET" | "POST",
    body?: any,
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;

    const headers = {
      ...(this.credentials && { "Grpc-Metadata-macaroon": this.credentials }),
      "Content-Type": "application/json",
    };

    const options: RequestInit = {
      method,
      headers,
      body: body ? JSON.stringify(body) : undefined,
    };

    try {
      const response = await fetch(url, options);
      if (!response.ok) {
        let errorBody = await response.text();
        try {
          const errorJson = JSON.parse(errorBody);
          errorBody = errorJson.error || errorBody;
        } catch {}
        throw new Error(
          `LND API Error ${response.status} (${response.statusText.toString()}): ${JSON.stringify(errorBody)}`,
        );
      }
      if (
        response.status === 204 ||
        response.headers.get("content-length") === "0"
      ) {
        return {} as T;
      }
      const text = await response
        .text()
        .then((r) => r.trim().split("\n").reverse()[0]);
      return JSON.parse(text);
    } catch (error) {
      console.error("REST Request Failed:", error);
      throw error;
    }
  }
}

export class Client implements base.Client {
  private readonly client: ClientInner;

  constructor(config: LndConfig) {
    this.client = new ClientInner(config);
  }

  async getInfo(): Promise<base.NodeInfo> {
    return this.client
      .request<GetInfoResponse>("/v1/getinfo", "GET")
      .then(fromGetInfoResponse);
  }

  async listChannels(): Promise<base.Channel[]> {
    return this.client
      .request<ListChannelsResponse>("/v1/channels", "GET")
      .then((res) => res.channels.map(fromChannel));
  }

  async getHealth(): Promise<base.HealthResponse> {
    const [node, channels] = await Promise.all([
      this.getInfo(),
      this.listChannels(),
    ]);
    return { node, channels };
  }

  async getInvoices(req: base.GetInvoicesRequest): Promise<base.InvoiceFull[]> {
    const query = new URLSearchParams(
      toListInvoicesRequest(req) as Record<string, string>,
    );
    return await this.client
      .request<ListInvoicesResponse>(`/v1/invoices?${query}`, "GET")
      .then((res) => res.invoices.map(fromInvoiceFull));
  }

  async makeInvoice(
    req: base.MakeInvoiceRequest,
  ): Promise<base.MakeInvoiceResponse> {
    return this.client
      .request<AddInvoiceResponse>(
        "/v1/invoices",
        "POST",
        toAddInvoiceRequest(req),
      )
      .then(fromAddInvoiceResponse);
  }

  public async pay(req: base.PayRequest): Promise<base.PayResponse> {
    console.log("PAY");
    console.log(req);
    return await this.client
      .request<SendPaymentResponse>(
        "/v2/router/send",
        "POST",
        toSendPaymentRequest(req),
      )
      .then((r) => r.result)
      .then(toSendPaymentResponse);
  }
}

interface GetInfoResponse {
  synced_to_chain: boolean;
  identity_pubkey: string;
  version: string;
  alias: string;
  num_pending_channels: number;
  num_active_channels: number;
  block_height: number;
}

interface ListChannelsResponse {
  channels: Channel[];
}

const fromChannel = (c: Channel): base.Channel => ({
  pubkey: c.remote_pubkey,
  capacity: BigInt(c.capacity),
  active: c.active,
  localBalance: BigInt(c.local_balance),
  remoteBalance: BigInt(c.remote_balance),
  commitFee: BigInt(c.commit_fee),
  unsettledBalance: BigInt(c.unsettled_balance),
});

const fromGetInfoResponse = (info: GetInfoResponse): base.NodeInfo => ({
  publicKey: info.identity_pubkey,
  synced: info.synced_to_chain,
  version: info.version,
  alias: info.alias,
  numPendingChannels: info.num_pending_channels,
  numActiveChannels: info.num_active_channels,
  blockHeight: info.block_height,
});

// Generated by gemini
interface Channel {
  active: boolean;
  remote_pubkey: string;
  channel_point: string; // e.g., 'txid:vout'
  chan_id: string; // The channel ID in string format
  capacity: string; // Amount in satoshis (string)
  local_balance: string; // Amount in satoshis (string)
  remote_balance: string; // Amount in satoshis (string)
  commit_fee: string; // Fee in satoshis (string)
  commit_weight: string;
  fee_per_kw: string;
  unsettled_balance: string; // Amount in satoshis (string)
  total_satoshis_sent: string;
  total_satoshis_received: string;
  num_updates: string;
  pending_htlcs: any[]; // Assuming an array of objects/any, can be defined more precisely if data is available
  csv_delay: number; // Number
  private: boolean;
  initiator: boolean;
  chan_status_flags: string; // e.g., 'ChanStatusDefault'
  local_chan_reserve_sat: string;
  remote_chan_reserve_sat: string;
  static_remote_key: boolean;
  commitment_type: string; // e.g., 'ANCHORS'
  lifetime: string;
  uptime: string;
  close_address: string;
  push_amount_sat: string;
  thaw_height: number;
  local_constraints: Record<string, any>; // [Object] placeholder
  remote_constraints: Record<string, any>; // [Object] placeholder
  alias_scids: any[];
  zero_conf: boolean;
  zero_conf_confirmed_scid: string;
  peer_alias: string;
  peer_scid_alias: string;
  memo: string;
  custom_channel_data: string;
}

interface ListChannelsResponse {
  channels: Channel[];
}

/**
 * Interface representing the optional fields in an invoice creation request body.
 * Note: Many numerical types (int64, uint64) are represented as strings
 * in JSON APIs to prevent JavaScript's number precision issues.
 */
interface AddInvoiceRequest {
  /** An optional memo to be included in the invoice. */
  memo?: string;
  /** The preimage hash to be used for the invoice (Base64 encoded bytes). */
  hash?: string;
  /** The invoice amount in satoshis (string encoded int64). */
  value?: string;
  /** The invoice amount in milli-satoshis (string encoded int64). */
  value_msat?: string;
  /** The hash of the description (Base64 encoded bytes). */
  description_hash?: string;
  /** The invoice expiry time in seconds (string encoded int64). */
  expiry?: string;
  /** A fallback address for on-chain settlement. */
  fallback_addr?: string;
  /** The minimum final CLTV expiry delta (string encoded uint64). */
  cltv_expiry?: string;
  /** An array of private routing hints. */
  route_hints?: any[]; // Use 'any[]' or define a specific 'RouteHint' interface
  /** Whether the invoice should include private route hints. */
  private?: boolean;
}

// Converts LND-style snake_case request to the modern camelCase type.
const toAddInvoiceRequest = (
  r: base.MakeInvoiceRequest,
): AddInvoiceRequest => ({
  ...(r.description && { memo: r.description }),
  ...(r.paymentHash && { hash: base64.encode(r.paymentHash) }),
  ...(r.amountMsat && { value_msat: String(r.amountMsat) }),
  ...(r.descriptionHash && {
    description_hash: base64.encode(r.descriptionHash),
  }),
  ...(r.expiry && { expiry: String(r.expiry) }),
  ...(r.fallbackAddr && { fallback_addr: r.fallbackAddr }),
  ...(r.cltvExpiry && { cltv_expiry: String(r.cltvExpiry) }),
  ...(r.routeHints && { route_hints: r.routeHints }),
  ...(r.isPrivate !== undefined && { private: r.isPrivate }),
});

interface AddInvoiceResponse {
  payment_request: string;
  add_index: string;
  payment_addr: string;
}

const fromAddInvoiceResponse = (
  r: AddInvoiceResponse,
): base.MakeInvoiceResponse => ({
  paymentRequest: r.payment_request,
  addIndex: BigInt(r.add_index),
  paymentAddress: base64.decode(r.payment_addr),
});

interface ListInvoicesRequest {
  pending_only?: boolean;
  index_offset?: string;
  num_max_invoices?: string;
  reversed?: boolean;
  creation_date_start?: string;
  creation_date_end?: string;
}

const toListInvoicesRequest = (
  r: base.GetInvoicesRequest,
): ListInvoicesRequest => ({
  ...(r.isPending !== undefined && { pending_only: r.isPending }),
  ...(r.indexOffset && { index_offset: String(r.indexOffset) }),
  ...(r.limit && { num_max_invoices: String(r.limit) }),
  ...(r.isReversed !== undefined && { reversed: r.isReversed }),
  ...(r.after && { creation_date_start: String(r.after / 1000n) }),
  ...(r.before && { creation_date_end: String(r.before / 1000n) }),
});

interface ListInvoicesResponse {
  invoices: InvoiceFull[];
  last_index_offset: string;
  first_index_offset: string;
}

interface InvoiceFull {
  memo: string;
  r_preimage: string;
  r_hash: string;
  value: string;
  value_msat: string;
  settled: boolean;
  creation_date: string;
  settle_date: string;
  payment_request: string;
  description_hash: string;
  expiry: string;
  fallback_addr: string;
  cltv_expiry: string;
  route_hints: any[];
  private: boolean;
  add_index: string;
  settle_index: string;
  amt_paid_sat: string;
  amt_paid_msat: string;
  state: string;
  htlcs: any[];
  features: any;
  is_keysend: boolean;
  payment_addr: string;
  is_amp: boolean;
  amp_invoice_state: any;
  is_blinded: boolean;
  blinded_path_config: any;
}

const fromInvoiceFull = (r: InvoiceFull): base.InvoiceFull => ({
  description: r.memo,
  rPreimage: base64.decode(r.r_preimage),
  rHash: base64.decode(r.r_hash),
  valueSat: BigInt(r.value),
  valueMsat: BigInt(r.value_msat),
  isSettled: r.settled,
  createdOn: BigInt(r.creation_date),
  settledOn: BigInt(r.settle_date),
  paymentRequest: r.payment_request,
  descriptionHash: base64.decode(r.description_hash),
  expiry: BigInt(r.expiry),
  fallbackAddr: r.fallback_addr,
  cltvExpiry: BigInt(r.cltv_expiry),
  routeHints: r.route_hints,
  isPrivate: r.private,
  addIndex: BigInt(r.add_index),
  settleIndex: BigInt(r.settle_index),
  amountPaidSat: BigInt(r.amt_paid_sat),
  amountPaidMsat: BigInt(r.amt_paid_msat),
  state: r.state,
  htlcs: r.htlcs,
  features: r.features,
  isKeysend: r.is_keysend,
  paymentSecret: base64.decode(r.payment_addr),
  isAmp: r.is_amp,
  ampInvoiceState: r.amp_invoice_state,
  isBlinded: r.is_blinded,
  blindedPathConfig: r.blinded_path_config,
});

interface SendPaymentRequest {
  dest?: string;
  amt?: string;
  payment_hash?: string;
  final_cltv_delta?: number;
  payment_request?: string;
  timeout_seconds?: number;
  fee_limit_sat?: string;
  outgoing_chan_id?: string;
  cltv_limit?: number;
  route_hints?: any[];
  dest_custom_records?: any;
  amt_msat?: string;
  fee_limit_msat?: string;
  last_hop_pubkey?: string;
  allow_self_payment?: boolean;
  dest_features?: any[];
  max_parts?: number;
  no_inflight_updates?: boolean;
  outgoing_chan_ids?: string[];
  payment_addr?: string;
  max_shard_size_msat?: string;
  amp?: boolean;
  time_pref?: number;
  cancelable?: boolean;
  first_hop_custom_records?: any;
}

interface SendPaymentResponse {
  result: SendPaymentResponseInner;
}

interface SendPaymentResponseInner {
  payment_hash: string;
  value: string;
  creation_date: string;
  fee: string;
  payment_preimage: string;
  value_sat: string;
  value_msat: string;
  payment_request: string;
  status: string;
  fee_sat: string;
  fee_msat: string;
  creation_time_ns: string;
  htlcs: any[];
  payment_index: string;
  failure_reason: string;
  first_hop_custom_records: any;
}

const toSendPaymentRequest = (r: base.PayRequest): SendPaymentRequest => ({
  ...(r.payee && { dest: base64.encode(r.payee) }),
  ...(r.paymentHash && { payment_hash: base64.encode(r.paymentHash) }),
  ...(r.paymentSecret && { payment_addr: base64.encode(r.paymentSecret) }),
  ...(r.finalCltvDelta !== undefined && { final_cltv_delta: r.finalCltvDelta }),
  ...(r.paymentRequest && { payment_request: r.paymentRequest }),
  ...(r.timeoutSeconds !== undefined && { timeout_seconds: r.timeoutSeconds }),
  ...(r.feeLimitSat && { fee_limit_sat: String(r.feeLimitSat) }),
  ...(r.outgoingChannelId && { outgoing_chan_id: String(r.outgoingChannelId) }),
  ...(r.cltvLimit !== undefined && { cltv_limit: r.cltvLimit }),
  ...(r.routeHints && { route_hints: r.routeHints }),
  ...(r.payeeCustomRecords && { dest_custom_records: r.payeeCustomRecords }),
  ...(r.amount && { amt_msat: String(r.amount) }),
  ...(r.feeLimit && { fee_limit_msat: String(r.feeLimit) }),
  ...(r.lastHopPubkey && { last_hop_pubkey: base64.encode(r.lastHopPubkey) }),
  ...(r.allowSelfPayment !== undefined && {
    allow_self_payment: r.allowSelfPayment,
  }),
  ...(r.payeeFeatures && { dest_features: r.payeeFeatures }),
  ...(r.maxParts !== undefined && { max_parts: r.maxParts }),
  ...(r.noInflightUpdates !== undefined && {
    no_inflight_updates: r.noInflightUpdates,
  }),
  ...(r.outgoingChannelIds && {
    outgoing_chan_ids: r.outgoingChannelIds.map(String),
  }),
  ...(r.maxShardSizeMsat && {
    max_shard_size_msat: String(r.maxShardSizeMsat),
  }),
  ...(r.isAmp !== undefined && { amp: r.isAmp }),
  ...(r.timePref !== undefined && { time_pref: r.timePref }),
  ...(r.isCancelable !== undefined && { cancelable: r.isCancelable }),
  ...(r.firstHopCustomRecords && {
    first_hop_custom_records: r.firstHopCustomRecords,
  }),
});

const toSendPaymentResponse = (
  r: SendPaymentResponseInner,
): base.PayResponse => ({
  rHash: base16.decode(r.payment_hash.toUpperCase()),
  valueSat: BigInt(r.value_sat || r.value || "0"),
  creationDate: BigInt(r.creation_date),
  feeSat: BigInt(r.fee_sat || r.fee || "0"),
  rPreimage: base16.decode(r.payment_preimage.toUpperCase()),
  valueMsat: BigInt(r.value_msat),
  paymentRequest: r.payment_request,
  status: r.status,
  feeMsat: BigInt(r.fee_msat),
  creationTimeNs: BigInt(r.creation_time_ns),
  htlcs: r.htlcs,
  paymentIndex: BigInt(r.payment_index),
  failureReason: r.failure_reason,
  firstHopCustomRecords: r.first_hop_custom_records,
});

/// USEFUL FOR DEBUGGING!
function tee<T>(value: T): T {
  console.log("TEE", value);
  return value;
}
